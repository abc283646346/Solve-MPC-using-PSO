//
// Copyright 2018 TASS International.
//
// All rights reserved.
//
// Author: Changjie Guan (changjie.guan@tassinternational.com)
//

/*Particle Swarm Optimization
 * specially designed for model predictive control
 * */
#ifndef __PSO_HPP__
#define __PSO_HPP__

#include <random>
#include <iostream>
#include <iomanip>

#define PI 3.1415926
#define PSO_INERTIA 0.7298

#define SWARM_SIZE 64
#define HORIZON 25
#define D_STATE 6
#define D_INPUT 2

typedef float dtype;


struct State
{
	dtype x,y,psi,v,cte,epsi;
};

struct Input
{
	dtype delta;
	dtype a;
};

struct States
{
	//x,y,psi,v,cte,epsi;
	dtype x[HORIZON];
	dtype y[HORIZON];
	dtype psi[HORIZON];
	dtype v[HORIZON];
	dtype cte[HORIZON];
	dtype epsi[HORIZON];
};

struct Inputs
{
	dtype delta[HORIZON-1];
	dtype a[HORIZON-1];
};

struct Solver_ARG
{
	State initState;
	dtype coeffs[3];

	Inputs init_guess;
};

struct Particle
{
	States state;
	Inputs input;
	Inputs vel;
	Inputs input_b;

	dtype coeffs[3];	// [0 1 2]
};

struct Swarm
{
	Particle particle[SWARM_SIZE];	// a swarm of particles

	dtype fit[SWARM_SIZE];		// personal cost at each step
	dtype fit_bp[SWARM_SIZE];	// personal best cost over all steps

	Particle p_best;			// global best particle
	dtype fit_b;				// global best cost

	size_t index_best;			// index of global best particle

	dtype w;					// weight of previous velocity
	size_t step;				// current step number

};


struct PSO_Setting
{
	dtype tol;
	size_t MAX_STEP;
	size_t dec_stage;

	size_t step;
	size_t stop_size;

	// input limits
	dtype lb_d;
	dtype lb_a;
	dtype ub_d;
	dtype ub_a;

	dtype c1,c2;
	dtype w_max, w_min;
};

struct MPC_Setting
{
	dtype dt;
	dtype Lf;
	dtype ref_v;
	dtype w_cte;
};

struct MPC_PSO_Solver
{
	Swarm m_swarm;

	PSO_Setting m_pso_setting;
	MPC_Setting m_mpc_setting;

	Solver_ARG m_arg;

	Input m_result;

	dtype m_rst[8];


	// uniformed random numbers
	dtype m_rho1[SWARM_SIZE][HORIZON-1];
	dtype m_rho2[SWARM_SIZE][HORIZON-1];

	std::random_device m_rd;  //Will be used to obtain a seed for the random number engine
	std::mt19937 m_gen;

	MPC_PSO_Solver()
	{
		m_gen = std::mt19937(m_rd()); //Standard mersenne_twister_engine seeded with rd()
	}

	void getRNG()
	{
		std::uniform_real_distribution<> dis(0.0, 1.0);
		for (int n = 0; n < SWARM_SIZE; ++n) {
			for(int j=0;j<HORIZON;j++)
			{
				//Use dis to transform the random unsigned int generated by gen into a double in [0, 1)
				m_rho1[n][j] = dis(m_gen);
				m_rho2[n][j] = dis(m_gen);
			}
		}
	}

	void printRNG()
	{
		using std::cout;
		cout<<"rho_1 = \n";
		for(int i=0;i<SWARM_SIZE;i++)
		{
			for(int j=0;j<HORIZON;j++)
			{
				cout<<std::setprecision(3)<<m_rho1[i][j]<<"\t";
			}
			cout<<"\n";
		}
		cout<<"rho_2 = \n";
		for(int i=0;i<SWARM_SIZE;i++)
		{
			for(int j=0;j<HORIZON;j++)
			{
				cout<<std::setprecision(3)<<m_rho2[i][j]<<"\t";
			}
			cout<<"\n";
		}
	}

	void initSettings();
	void setMPC(MPC_Setting &h_set);
	void setPSO(PSO_Setting &h_set);
	void initParticles();
	void evalFitness();
	void solve(Solver_ARG &h_arg, dtype* h_input);
	void printInfo();
};

#endif
